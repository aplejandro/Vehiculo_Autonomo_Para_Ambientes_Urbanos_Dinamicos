#!/usr/bin/env python

# Copyright (c) 2017 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

# The python path is now fixed to my solution
# TODO, make the path more flexible
# TODO: clarify, why py2.7 works and py 3.5 doesn't
try:
    sys.path.append(glob.glob('../carla/dist/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])
except IndexError:
    pass

import carla
from agents.navigation.roaming_agent import RoamingAgent

# random is necessary for the choice of the vehicle
import random
import time

import math

actor_duration = 30.0

def main():
    # The actor list is necessary, because we need to keep track of all created actors.
    # Thatway, we can delete all actors at the end.
    actor_list = []

    # In this tutorial script, we are going to add a vehicle to the simulation
    # and let it drive in autopilot. We will also create a camera attached to
    # that vehicle, and save all the images generated by the camera to disk.

    try:
        # First of all, we need to create the client that will send the requests
        # to the simulator. Here we'll assume the simulator is accepting
        # requests in the localhost at port 2000# print(current_vehicle_waypoint.transform.location).
        client = carla.Client('localhost', 2000)
        client.set_timeout(2.0)

        # Once we have a client we can retrieve the world that is currently
        # running.
        world = client.get_world()

        # Get the map of the World
        map = world.get_map()



        # The world contains the list blueprints that we can use for adding new
        # actors into the simulation.
        blueprint_library = world.get_blueprint_library()

        # Now let's filter all the blueprints of type 'vehicle' and choose one
        # at random.
        bp = random.choice(blueprint_library.filter('vehicle'))

        # choose first possible spawn point
        transform = world.get_map().get_spawn_points()[0]
        print(transform)

        # So let's tell the world to spawn the vehicle.
        vehicle = world.spawn_actor(bp, transform)

        # It is important to note that the actors we create won't be destroyed
        # unless we call their "destroy" function. If we fail to call "destroy"
        # they will stay in the simulation even after we quit the Python script.
        # For that reason, we are storing all the actors we create so we can
        # destroy them afterwards.
        actor_list.append(vehicle)
        print('created %s' % vehicle.type_id)

        # create an RoamingAgent object
        roaming_agent = RoamingAgent(vehicle)

        start_time = time.time()
        bRunSim = True
        # run the simulation
        while bRunSim:

            # run step and apply control
            control = roaming_agent.run_step()


            # apply the control object
            vehicle.apply_control(control)


            # get spectator,
            spectator = world.get_spectator()

            # get ego vehicle transform for spectator transform
            spectator_transform = vehicle.get_transform()

            # go backwards
            forward_vector = spectator_transform.get_forward_vector()
            print(forward_vector)
            view_distance = 8
            spectator_transform.location.x -= forward_vector.x * view_distance
            spectator_transform.location.y -= forward_vector.y * view_distance

            # spectator upwards
            spectator_transform.location.z += 3

            # look downwards
            spectator_transform.rotation.pitch -= 20

            # set spectator position
            spectator.set_transform(spectator_transform)
            # print(spectator.get_transform())

            time.sleep(1.0/60)

            if (time.time() - start_time) > actor_duration:
                bRunSim = False

    finally:

        print('destroying actors')
        for actor in actor_list:
            actor.destroy()
        print('done.')


if __name__ == '__main__':

    main()
